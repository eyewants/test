#aos-team 11 (Project 4)
##Analyzing Memory Duplication in Tizen

#####Requirements of project 4
The main purpose of this project is to analyze page-level duplication in Tizen to report how efficiently Tizen uses memory. The project has two parts: 1) accurately measuring the level of memory duplication by building a tool, and 2) finding out the root causes of the problem if exists. The second part is for extra credit.

##Introduction
To detect page duplication, our tool, _MDdetector_, has two parts: _Page Fetcher_ and _Duplication analyzer_.  
Page Fetcher is our kernel module implementation, obtaining the contents of pages and computing the hash value of the page; and then, saving the hash value along with its physical frame number.  
For this task, Page Fetcher gets the pointer of virtaul memorty address by traversing _vm_area_struct_ structure of each task and translates the virtual address to the physical one by looking up the page table in a process called a page walk. In our implementation this page walking is performed by means of the function _follow_page_. This function returns the mapped _struct page *_, or NULL if no mapping exists. After temporarily mapping user space pages to the kernel with _kmap_atomic_, we read the page contents and calculate the hash values with _jhash2_ function. In addition, the physcial frame number of the page, _pfn_, is also calculated by _page_to_pfn_. Page Fetcher saves all this information to the file for a further analysis of the page duplication.  
Based on this file, Duplication Analyzer, being implemented in Python code, can report the number of duplicated pages.


##Usage
####Page Fetcher  
1. Loadable Kernel Module(LKM)  
2. Code location:  
	```
	proj4-tizen/linux-3.0/pageFetcher/pageFetcher.c
	```  
3. How to use the module pageFetcher. 
	1. Go to pageFetcher location
	 	```
		mv linux-3.0/pageFetcher
		```
	2. Complie the module 
		```
		make 
		```
	3. Copy the module to the device
		```
		sdb push pageFetcher.ko /home/developer 
		```

	4. Insert the module as follows in sdb shell:
		```
		sdb root on
		sdb shell insmod /home/developer/pageFetcher.ko
		```
	
	5. Remove the module as follows in sdb shell:
		```	
		sdb root on
		sdb shell rmmod pageFetcher.ko
		```
	4. pageFetcher gerneates the output file named _result.dump_ in the form of tuple (Physical page frame number, Virtual address, Hash value)
	
		```	
		comm:systemd, pid:1  
		0x0007fe00, 0x00008000, 4234942503  
		0x0007fe01, 0x00009000, 2972783174  
		0x0007fe02, 0x0000a000, 3427527307  
		0x0007fe03, 0x0000b000, 1905900417  
		...  
		comm:Xorg, pid:2094  
		0x0007e355, 0x00008000, 1779203799  
		0x0007e356, 0x00009000, 3539347856  
		0x0007e357, 0x0000a000, 3039845387  
		0x0007e358, 0x0000b000, 2443536629  
		```
 
####Memory Duplication Analayzer
1. Python script  
2. Code location:    
	```  
	proj4-tizen/linux-3.0/MemoryDuplicationAnalzyer/MemoryDuplicationAnalzyer.py
	```    
	
3. How to use the Memory Duplication Analzyer
	1. Change the diectory to MemoryDuplicationAnalzyer location
	 	```
		mv MemoryDuplicationAnalzyer
		```
	2. Get dump file, being generated by PageFetcher, from device. 
		```  
		sdb pull /home/developer/result.dump . 
		```
	3. running the MDanalzyer
		```
		python MDanalzyer.py
		```

	4. Test result will be showin in the ouput file, _MDAnalyzer_output.txt_ as follows.
		```  
		1. Test Results  
		==========================================  
		Total pages: 95525  
		The number of pages shared: 58059  
		The number of pages duplicated: 4682  
		==========================================
		
		2. Duplication Table Structure  
		-----------------------------------  
		Hash1  
		  Physical page frame number  
		    Task(Pid)  
		Hash2  
		  Physical page frame number  
		    Task(Pid)  
		...  
		-----------------------------------  

		3. Duplication Table  
		-----------------------------------  
		2952775000  
		  0x0007482d  
		    launchpad-proce(2321)  
		  0x000708ce   
		    launchpad-proce(4606)  
		1119025011  
		  0x00078fc2  
		    Xorg(2094)  
		  0x0007afc2  
		    Xorg(2094)  
		  0x0007dccf  
		    Xorg(2094)  
		```  

##Implementation
####Page Fetcher
1. Working flow  
  for_each_process(task)  
  → struct mm_struct *mm;   
  → vm_area_struct *mmap (vm_start - vm_end)  
  → struct page *follow_page: page table walking  
  → kmap_atomic(page): temporarily create a kernel-space address for specific high-memory pages  
  → calculate hash value of a page with jhash2 
  → page_to_pfn: page frame number  
  → save all memory information to the file: physical frame number

2. data structures and functions  
	```  
	Defined as a function in /mm/memory.c    
	/**    
 	* follow_page - look up a page descriptor from a user-virtual address  
 	* @vma: vm_area_struct mapping @address  
	* @address: virtual address to look up  
 	* @flags: flags modifying lookup behaviour  
 	*  
 	* Returns the mapped (struct page *), %NULL if no mapping exists, or  
 	* an error pointer if there is a mapping to something not represented  
 	* by a page descriptor (see also vm_normal_page()).  
 	*/  
	struct page *follow_page(struct vm_area_struct *vma, unsigned long address,
			unsigned int flags)
	```  	 
	```  
	Defined as a function in: include/linux/jhash.h  
 
	/* jhash2 - hash an array of u32's  
	 * @k: the key which must be an array of u32's  
	 * @length: the number of u32's in the key  
	 * @initval: the previous hash, or an arbitray value  
	 *  
	 * Returns the hash value of the key.  
	 */  
	 static inline u32 jhash2(const u32 *k, u32 length, u32 initval)  
  	```  
  	
####Memory Duplication Analzyer
1. Memory Duplication Analyzer parses input file, _result.dump_ generated by pageFetcher and gets the hash value of a physical page.
2. To detemine the duplication, it puts hash values to secondary hash list with element 5000.
3. After parsing the input file, it shows the duplication rate and generates the duplication table. 


##Discussion  
####Investiageion
1. accurately measuring the level of memory duplication by building a tool
2. finding out the root causes of the problem if exists. The second part is for extra credit

####test results  
1. without test applications  
	```  
	total pages            89,921     
	shared pages           55,140   
	duplicated pages        4,153
	duplication rate:       4.61%
	```  

2. with test application  
	We got the duplication test results with running following applications: download manager, eventmanager, bluetoothchat, calculator, contacts, filemanager, media, notification manager, pinao, scheduler, sensor are launched at one before fetching page info

	```  
	total pages            196,605  
	shared pages           108,482    
	duplicated pages        27,930
	duplication rate:       14.20%
	```  

##References  
1. ARCANGELI, A., EIDUS, I., AND WRIGHT, C. Increasing memory density by using ksm. In Proceedings of the linux symposium (2009), pp. 19–28.
